synth device provider
---------------------

- handling arbitrary synthesizers
-- modular vs. non-modular synthesizers
   the different between both models is that a non-modular synthesizer
   patch *always*
   - contains exactly one module

-- views
   a patch or a portion of the patch can be be associated with
   different views

-- seperate module properties
   a module should have a module-view property containing
   properties like location (x, y) that might be part of the
   module. Thus it is possible to support different views for
   a patch although the synthesizer does not support them
   while some helper tool automatically adjusts the module settings

-- handling properties not supported by the synthesizer:
   - when a patch is received from the synthesizer it can be compared
   with the patches in the library so that the patch from the library
   containing additional information is used rather then the patch
   received from the synth
   - if the synthesizer supports custom values a patch could have
     an unique identifier and info where to obtain the full patch from.
   - unique id:
     the unique id can be build from one or several properties:
     - version
     - author
     - url
     - creation date

--- possible views
    - patch settings : view for patch settings
    - instrument view : shows a customized view of the patch
    - group/template view : shows an arbitrary collection of modules
    - module view : shows a single module

- groups and templates
-- templates
   a template is a collection of modules
   - default values are retrieved from the template modules

- variations
   - variations are different parameter settings
   - a parameter should have a variation tag - one for each variation
   - parameters that do not vary have no need for such a tag
   
   examle:
   <parameter>
     <value>current-value</value>
     <value variation="1">2</value>
     <value variation="2">12</value>
     <value variation="3">45</value>
     <value variation="4">19</value>
   </parameter>
   <parameter>
     <value>current-value</value>
     <!-- no variations -->
   </parameter>

- wiring
   different synthesizers might have different rules for wiring
   thus it would be good to have s.th. like a WireManager/CableManager
   for handling cables (create, delete, module-delete=>delete connection ...)

specs and implementation
------------------------

- implementations also implement spec interface

  example:
  
  ParameterSpec
  {
  	int defaultValue()
  	int value()
  	{
  		return defaultValue()
    }
  }
  
  ParameterImpl
  {
    int defaultValue()
    int currentValue()
    int value()
    {
    	return currentValue()
    }
  }

architecture
------------

virtual::patch extends group ::=

    group* {
	
	    template-reference? // if the group is a template

		module* implements module-spec
		{
			module-spec
			%module-attributes
			parameter*
			{
				parameter-spec
			}
			interface*
			{
				interface-spec
			}
		}
		
	}

%module-attributes ::=
	name
	

spec::module-spec ::=
	{
		parameter-spec*
		name
		id
		{
		
		}
		interface-spec*
		{
			type ::= input|output //|both
		}
	}

view ::=
	patch
