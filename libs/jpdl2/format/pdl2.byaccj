%{
import java.io.*;
import net.sf.nmedit.jpdl2.impl.*;
import java.util.ArrayList;
import java.util.List;
import net.sf.nmedit.jpdl2.*;
%}
      
%token NL          /* newline  */

%token <ival> DEC_INTEGER_LITERAL;
%token <ival> HEX_INTEGER_LITERAL;
%token <ival> DUAL_INTEGER_LITERAL;
%token <sval> STRING_LITERAL;
%token <ival> BOOLEAN_LITERAL;

%token <sval> LABEL
%token <sval> PACKETREF
%token <sval> IDENTIFIER
%token LSHIFT
%token RSHIFT
%token URSHIFT
%token CMP_EQ
%token CMP_NEQ
%token CMP_LT
%token CMP_LEQ
%token CMP_GT
%token CMP_GEQ
%token ASSIGN
%token CAST_TO_INT
%token CAST_TO_BOOLEAN
%token IF
%token TKDOLLAR
%token TK_MESSAGEID;
%token TK_FAIL;
%token TK_SWITCH;
%token TK_CASE;
%token TK_DEFAULT;

%type <ival> INTEGER_LITERAL 
%type <obj> PacketDecl PacketDeclStart PacketDeclList NextExpression StreamOp 
%type <obj> expression ConstExpr compiled_expression 
%type <obj> pdldocument  Constant  Multiplicity ConstantWithoutMuliplicity   
%type <obj> RawVariable Variable RawVariableList VariableList ImplicitVariable
%type <obj> IfStatement IfExpression
%type <obj> PacketRef PacketRefList pdlheader pdlbody
%type <obj> Block   Item BlockItem  ItemList SimpleItem TypeCastExpr MessageId MutualExclusion MutualExclusionStatement
%type <obj> FailStatement SwitchStatement SwitchStatementHeader SwitchCaseList CaseStatement
%type <sval> PacketName
%type <ival> StreamOpToken

%nonassoc IF
/* groups of equal precedence, increasing priority from top to bottom */
%left CMP_EQ CMP_NEQ CMP_LT CMP_LEQ CMP_GT CMP_GEQ 
%left '&' '|' '^'
%left '+' '-'
%left '*' '/' '%'
%left NEG
%right '~' '!' CAST_TO_INT CAST_TO_BOOLEAN

%start pdldocument

%%

pdldocument:
          /* empty */    {}
       | pdlbody {}
       | pdlheader pdlbody {}
       ;

pdlheader:
        IDENTIFIER IDENTIFIER ';' { if (!$1.equals("start")) throw new PDLException("'start' expected"); pdldoc.setStartPacketName($2); }
	;

pdlbody:
		PacketDeclList { $$=$1; }
	;

PacketDeclList:
            PacketDecl                
          | PacketDecl PacketDeclList 
       ;

PacketDecl:
          PacketDeclStart ASSIGN 
                                         
                                         { /* action:before ItemList */
                                           PDLPacketDeclImpl pdecl = (PDLPacketDeclImpl)$1;
                                           bpush(pdecl);
                                           $$ = pdecl;
                                           registerPacketDecl(pdecl); 
                                         }
                                         
                                         ItemList ";" 
                                         
                                         { /* action:after ItemList */
                                           bpop();
                                         }
       |  /* empty packet */ 
          PacketDeclStart ASSIGN ';' { registerPacketDecl((PDLPacketDeclImpl)$1);  }
       ;

PacketDeclStart:
          PacketName '%' INTEGER_LITERAL { int padding = $3;
                                           if(padding<1)
                                             yyerror("padding must >=1: "+padding);
                                              
                                           $$ = new PDLPacketDeclImpl($1, padding); }
       |  PacketName                     { $$ = new PDLPacketDeclImpl($1, 1); /* default padding = 1 */ }
       ;

Multiplicity:
         IDENTIFIER '*'              { $$ = new PDLMultiplicityImpl($1); }
       | INTEGER_LITERAL '*'         { $$ = new PDLMultiplicityImpl($1); }
       | '*'                         { yyerror("*-multiplicity not implemented");
                                       //$$ = new PDLMultiplicityImpl(PDLMultiplicityType.NoneOrMany); 
                                     }
       | '+'                         { yyerror("+-multiplicity not implemented");
                                       //$$ = new PDLMultiplicityImpl(PDLMultiplicityType.OneOrMany); 
                                     }
       ;

PacketName:
          IDENTIFIER 
       ;
       
SimpleItem:
          LABEL     { badd(new PDLLabelImpl($1)); }
       |  PacketRef 
       |  PacketRefList
       |  Variable  
       |  VariableList
       |  ImplicitVariable
       |  Constant  
       |  MessageId
       |  MutualExclusionStatement
       |  FailStatement
       |  SwitchStatement
       ;

FailStatement:
         TK_FAIL    { badd(new PDLInstructionImpl(PDLItemType.Fail)); }
       ;

SwitchStatement:
         SwitchStatementHeader '{' SwitchCaseList '}' { bpop(); }
       ;

SwitchStatementHeader:
         TK_SWITCH '(' expression ')' { PDLSwitchStatementImpl s = new PDLSwitchStatementImpl((Expression)$3); badd(s); bpush(s); }
       ;

SwitchCaseList:
         CaseStatement              
       | CaseStatement SwitchCaseList
	   ;

CaseStatement:
         TK_CASE INTEGER_LITERAL ':' { PDLCaseStatementImpl c = new PDLCaseStatementImpl(false, $2); badd(c); bpush(c); } Block { $$=$4; bpop(); }
       | TK_DEFAULT ':'              { PDLCaseStatementImpl c = new PDLCaseStatementImpl(true, -1);  badd(c); bpush(c); } Block { $$=$3; bpop(); }
       ;

MutualExclusionStatement:
       '(' MutualExclusion ')'          { $$=$2; }
       ;

MutualExclusion:
          { PDLMutualExclusionImpl m = new PDLMutualExclusionImpl(); badd(m); bpush(m); } Item '|' Item { bpop(); }
       |  MutualExclusion '|' Item      { $$ = $1; }
       ;

MessageId:
          TK_MESSAGEID '(' STRING_LITERAL ')' { badd(new PDLInstructionImpl(PDLItemType.MessageId, $3)); }
       ;

Variable:
          RawVariable { badd($1); }
       ;

RawVariable:
          IDENTIFIER ':' INTEGER_LITERAL { PDLUtils.checkBitcount($3);
                                           $$=new PDLVariableImpl($1, $3); }
       ;

ImplicitVariable:
          RawVariable '=' '(' expression ')' { badd(new PDLImplicitVariableImpl((PDLVariable)$1, new PDLFunctionImpl((Expression)$4)));  }
       ;

VariableList:
          RawVariableList { badd($1); }
       |  RawVariableList '/' INTEGER_LITERAL { PDLVariableListImpl v = (PDLVariableListImpl) $1; v.setTerminal($3); badd($1); }
       ;

RawVariableList:
          Multiplicity RawVariable { $$=new PDLVariableListImpl((PDLVariable)$2, (PDLMultiplicity)$1); }
       ;

Constant:
          ConstantWithoutMuliplicity {  badd($1); }
       |  Multiplicity ConstantWithoutMuliplicity { ((PDLConstantImpl)$2).setMultiplicity((PDLMultiplicityImpl)$1); badd($2); }
       ;

ConstantWithoutMuliplicity:
          INTEGER_LITERAL ':' INTEGER_LITERAL { PDLUtils.checkBounds($1, $3);
                                                $$ = new PDLConstantImpl($1, $3); }  
       ;

PacketRef:
          PACKETREF { badd(textToPacketRef($1)); }
       ;

PacketRefList:
          Multiplicity PACKETREF { badd(new PDLPacketRefListImpl(textToPacketRef($2), (PDLMultiplicity)$1)); }
       ;

Item: 
          BlockItem     
       |  SimpleItem
       ;

BlockItem:
          IfStatement   { $$=$1; }
       |  '?' { PDLOptionalImpl o = new PDLOptionalImpl(); badd(o); bpush(o); }  Block { bpop(); }
       ;

IfStatement:
           IF '(' IfExpression ')'   {  PDLConditionalImpl c = new PDLConditionalImpl((PDLCondition) $3); badd(c); bpush(c); $$ = c;  }
                                     Block { bpop(); }
       ;

Block:     SimpleItem           { }
       |   '{' '}'              { badd(new PDLBlockItemImpl()); }
       |   '{' { PDLBlockItemImpl b = new PDLBlockItemImpl(); badd(b); bpush(b); } ItemList '}' { bpop(); }
       ;

ItemList:
         Item ItemList 
       | Item
       ;

IfExpression:
         compiled_expression         { $$ = new PDLCompiledCondition((Expression)$1); }  
       ;

INTEGER_LITERAL:  
         DEC_INTEGER_LITERAL
       | HEX_INTEGER_LITERAL 
       | DUAL_INTEGER_LITERAL 
	   ;

compiled_expression:
          expression                { $$ = $1; }
       ;

expression: 
          ConstExpr
       |  StreamOp
       |  TypeCastExpr 
       /* CompareExpr */ 
       |  expression CMP_EQ expression  { $$ = Expression.cmpEq ( (Expression) $1, (Expression) $3 ); }
       |  expression CMP_NEQ expression { $$ = Expression.cmpNeq( (Expression) $1, (Expression) $3 ); }
       |  expression CMP_LT expression  { $$ = Expression.cmpLt ( (Expression) $1, (Expression) $3 ); }
       |  expression CMP_LEQ expression { $$ = Expression.cmpLEq( (Expression) $1, (Expression) $3 ); }
       |  expression CMP_GT expression  { $$ = Expression.cmpGt ( (Expression) $1, (Expression) $3 ); }
       |  expression CMP_GEQ expression { $$ = Expression.cmpGEq( (Expression) $1, (Expression) $3 ); }
       /* AdditiveExpr */
       |  expression '+' expression     { $$ = Expression.add   ( (Expression) $1, (Expression) $3 ); }
       |  expression '-' expression     { $$ = Expression.minus ( (Expression) $1, (Expression) $3 ); }
       |  expression '&' expression     { $$ = Expression.and   ( (Expression) $1, (Expression) $3 ); }
       |  expression '|' expression     { $$ = Expression.or    ( (Expression) $1, (Expression) $3 ); }
	   /* MultiplicativeExpr */
       |  expression '*' expression     { $$ = Expression.mul   ( (Expression) $1, (Expression) $3 ); }
       |  expression '/' expression     { $$ = Expression.div   ( (Expression) $1, (Expression) $3 ); }
       |  expression '%' expression     { $$ = Expression.mod   ( (Expression) $1, (Expression) $3 ); }
       |  expression '^' expression     { $$ = Expression.xor   ( (Expression) $1, (Expression) $3 ); }
       /* UnaryExpr */
       |  '~' expression %prec NEG      { $$ = Expression.inv( (Expression) $2 ); }
       |  '!' expression %prec NEG      { $$ = Expression.inv( (Expression) $2 ); }
       |  '-' expression %prec NEG      { $$ = Expression.neg( (Expression) $2 ); }
       /* brackets */
       |  '(' expression ')'            { $$ = $2; }
       ;

ConstExpr:
          TKDOLLAR                  { $$ = new Expression(Opcodes.fpush); }
       |  INTEGER_LITERAL           { $$ = new Expression(Opcodes.ipush, $1 ); }
       |  BOOLEAN_LITERAL           { $$ = new Expression(Opcodes.bpush, $1==1?true:false); }
       |  LABEL                     { $$ = new Expression(Opcodes.lpush, (String)$1); }
       |  IDENTIFIER                { $$ = new Expression(Opcodes.vpush, (String)$1); }
       ;

TypeCastExpr:
          CAST_TO_INT expression { $$ = Expression.castToInt((Expression) $2); }
       |  CAST_TO_BOOLEAN expression { $$ = Expression.castToBoolean((Expression) $2); }
       ;

StreamOp: 
          '[' StreamOpToken 
          NextExpression 
          NextExpression 
          NextExpression
          NextExpression 
          ']'                   {   $$ = new Expression($2, 
                                           (Expression)$3, (Expression)$4, 
                                           (Expression)$5, (Expression)$6); }
       ;

NextExpression:   
          ';' expression  { $$=$2; }
       ;
       
StreamOpToken:
           '&' { $$=Opcodes.land; }
       |   '|' { $$=Opcodes.lor; }
       |   '^' { $$=Opcodes.lxor; }
       |   '*' { $$=Opcodes.lmul; }
       |   '+' { $$=Opcodes.ladd; }
       ;

%%
  /* a reference to the lexer object */
  private PDL2Lexer lexer;
  
  private PDLDocumentImpl pdldoc = new PDLDocumentImpl();

  public PDLDocument getDocument()
  {
     return pdldoc;
  }

  // PDLBlock and mutualExclusion elements
  private List<Object> bstack = new ArrayList<Object>();
  
  private static final boolean PDLDebug = false;
  
  private void bpush(Object b)
  {
    if (PDLDebug) System.out.println("bpush:"+b);
    
    if ((b instanceof PDLBlock) || (b instanceof PDLMutualExclusionImpl)
     || (b instanceof PDLSwitchStatementImpl)
     || (b instanceof PDLCaseStatementImpl))
        bstack.add(b);
    else
        throw new ClassCastException();
  }
  
  private void bpop()
  {
    if (PDLDebug) System.out.println("bpop");
    bstack.remove(bstack.size()-1);
  }
  
  private void badd(Object item) throws PDLException
  {
    if (item == null) throw new PDLException("error in parser: cannot add null to parent block");
  
    if (PDLDebug) System.out.println("badd:"+item);
    Object p = bstack.get(bstack.size()-1);
    
    if (p instanceof PDLBlock)
    	((PDLBlock)p).add((PDLItem)item);
    else if (p instanceof PDLMutualExclusionImpl)
        ((PDLMutualExclusionImpl)p).add((PDLItem)item);
    else if (p instanceof PDLCaseStatementImpl)
        ((PDLCaseStatementImpl)p).add((PDLItem)item);
    else if (p instanceof PDLSwitchStatementImpl)
        ((PDLSwitchStatementImpl)p).add((PDLCaseStatementImpl)item);
    else throw new ClassCastException("could not determine type of"+item.getClass());
  }

  private PDLPacketRefImpl textToPacketRef(String s)
  {
    int i = s.indexOf('$');
    return new PDLPacketRefImpl(pdldoc, s.substring(0,i), s.substring(i+1));
  }

  private void registerPacketDecl(PDLPacketDecl p) throws PDLException
  {
     try
     {
        pdldoc.add(p);
     }
     catch (IllegalArgumentException e)
     {
        yyerror("multiple declarations of packet: "+p.getName());
        throw e; // in case no exception is thrown
     }
  }

  public void parse() throws PDLException
  {
     yyparse();
     PDLDocumentVerifier verifier = new PDLDocumentVerifier(pdldoc);
     verifier.verify();
  }

  /* interface to the lexer */
  private int yylex () {
    int yyl_return = -1;
    try {
      yyl_return = lexer.yylex();
    }
    catch (IOException e) {
      System.err.println("IO error :"+e);
    }
    return yyl_return;
  }
	

  /* error reporting */
  public void yyerror (String error) throws PDLException
  {
    throw new PDLException(
      "[line "+ lexer.getLineNumber()+":"+lexer.getColumnNumber()+"] "+error);
  }

  /* lexer is created in the constructor */
  public PDL2Parser(Reader r) {
    lexer = new PDL2Lexer(r, this);
  }

  /* that's how you use the parser */
  public static void main(String args[]) throws IOException, PDLException {
    PDL2Parser yyparser = new PDL2Parser(new FileReader(args[0]));
    yyparser.yyparse();    
  }